---
title: MD5
date: 2020-05-14 11:39:45
permalink: /pages/md5
article: false
---

::: details 关于 MD5 信息摘要算法
MD5 信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个 128 位（16 字节）的散列值（hash value），用于确保信息传输完整一致。MD5 由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于 1992 年公开，用以取代 MD4 算法。这套算法的程序在 [RFC 1321](https://www.rfc-editor.org/rfc/rfc1321.html) 标准中被加以规范。一个数据的 MD5 值是唯一的，同一个数据不可能计算出多个不同的 MD5 值，但是，不同数据计算出来的 MD5 值是有可能一样的，知道一个 MD5 值，理论上是无法还原出它的原始数据的，但 1996 年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如 SHA-2。2004 年，证实 MD5 算法无法防止碰撞（collision），因此不适用于安全性认证，如 SSL 公开密钥认证或是数字签名等用途。
::: right
MD5 [维基百科](https://wikipedia.org/wiki/MD5)
:::

## Python <Badge text="3.0+"/>

<code-group>
  <code-block title="依赖库 1️⃣" active>
  ```python
  # 方法一：直接使用 md5 函数

  import hashlib
  
  
  data = "spiderapi.cn - 虫术"
  
  result_lowercase_32bit = hashlib.md5(data.encode()).hexdigest()
  result_uppercase_32bit = result_lowercase_32bit.upper()
  result_lowercase_16bit = result_lowercase_32bit[8:-8]
  result_uppercase_16bit = result_lowercase_16bit.upper()
  
  print("32 位小写值: ", result_lowercase_32bit)
  print("32 位大写值: ", result_uppercase_32bit)
  print("16 位小写值: ", result_lowercase_16bit)
  print("16 位大写值: ", result_uppercase_16bit)
  ```
  </code-block>
  
  <code-block title="依赖库 2️⃣">
  ```python
  # 方法二：使用 new 函数创建 md5 对象

  import hashlib
  
  
  data = "spiderapi.cn - 虫术"
  
  result_lowercase_32bit = hashlib.new("md5", data.encode()).hexdigest()
  result_uppercase_32bit = result_lowercase_32bit.upper()
  result_lowercase_16bit = result_lowercase_32bit[8:-8]
  result_uppercase_16bit = result_lowercase_16bit.upper()
  
  print("32 位小写值: ", result_lowercase_32bit)
  print("32 位大写值: ", result_uppercase_32bit)
  print("16 位小写值: ", result_lowercase_16bit)
  print("16 位大写值: ", result_uppercase_16bit)
  ```
  </code-block>

  <code-block title="依赖库 3️⃣">
  ```python
  #  方法三：通过 update 方法更新 md5 对象

  import hashlib
  
  
  data = "spiderapi.cn - 虫术"
  
  hash_object = hashlib.md5()
  hash_object.update(data.encode())
  result_lowercase_32bit = hash_object.hexdigest()
  result_uppercase_32bit = result_lowercase_32bit.upper()
  result_lowercase_16bit = result_lowercase_32bit[8:-8]
  result_uppercase_16bit = result_lowercase_16bit.upper()
  
  print("32 位小写值: ", result_lowercase_32bit)
  print("32 位大写值: ", result_uppercase_32bit)
  print("16 位小写值: ", result_lowercase_16bit)
  print("16 位大写值: ", result_uppercase_16bit)
  ```
  </code-block>
  
  <code-block title="多种编码">
  ```python
  # encoding 支持多种编码

  import hashlib
  
  
  data = "spiderapi.cn - 虫术"
  
  result_utf8 = hashlib.md5(data.encode(encoding="UTF-8")).hexdigest()
  print("encoding utf-8:", result_utf8)
  
  result_gbk = hashlib.md5(data.encode(encoding="GBK")).hexdigest()
  print("encoding gbk:", result_gbk)
  
  result_gb2312 = hashlib.md5(data.encode(encoding="GB2312")).hexdigest()
  print("encoding gb2312:", result_gb2312)
  
  result_18030 = hashlib.md5(data.encode(encoding="GB18030")).hexdigest()
  print("encoding gb18030:", result_18030)
  ```
  </code-block>

  <code-block title="纯源码">
  ```python
  # 不借助官方或者第三方库，纯源码实现

  import binascii
  
  
  SV = [0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf,
      0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af,
      0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
      0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
      0xd62f105d, 0x2441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6,
      0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8,
      0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,
      0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039,
      0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97,
      0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
      0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
      0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391]
  
  
  def left_circular_shift(k, bits):
      bits = bits % 32
      k = k % (2 ** 32)
      upper = (k << bits) % (2 ** 32)
      result = upper | (k >> (32 - bits))
      return result
  
  
  def block_divide(block, chunks):
      result = []
      size = len(block) // chunks
      for i in range(0, chunks):
          result.append(int.from_bytes(block[i * size:(i + 1) * size], byteorder="little"))
      return result
  
  
  def F(X, Y, Z):
      return (X & Y) | ((~X) & Z)
  
  
  def G(X, Y, Z):
      return (X & Z) | (Y & (~Z))
  
  
  def H(X, Y, Z):
      return X ^ Y ^ Z
  
  
  def I(X, Y, Z):
      return Y ^ (X | (~Z))
  
  
  def FF(a, b, c, d, M, s, t):
      result = b + left_circular_shift((a + F(b, c, d) + M + t), s)
      return result
  
  
  def GG(a, b, c, d, M, s, t):
      result = b + left_circular_shift((a + G(b, c, d) + M + t), s)
      return result
  
  
  def HH(a, b, c, d, M, s, t):
      result = b + left_circular_shift((a + H(b, c, d) + M + t), s)
      return result
  
  
  def II(a, b, c, d, M, s, t):
      result = b + left_circular_shift((a + I(b, c, d) + M + t), s)
      return result
  
  
  def fmt8(num):
      big_hex = "{0:08x}".format(num)
      unhex = binascii.unhexlify(big_hex)
      result = "{0:08x}".format(int.from_bytes(unhex, byteorder='little'))
      return result
  
  
  def bit_len(bitstring):
      return len(bitstring) * 8
  
  
  def md5_hash(msg):
      # First, we pad the message
      msg_len = bit_len(msg) % (2 ** 64)
      msg = msg + b'\x80'
      zero_pad = (448 - (msg_len + 8) % 512) % 512
      zero_pad //= 8
      msg = msg + b'\x00' * zero_pad + msg_len.to_bytes(8, byteorder='little')
      msg_len = bit_len(msg)
      iterations = msg_len // 512
      # chaining variables
      A = 0x67452301
      B = 0xefcdab89
      C = 0x98badcfe
      D = 0x10325476
      # main loop
      for i in range(0, iterations):
          a = A
          b = B
          c = C
          d = D
          block = msg[i * 64:(i + 1) * 64]
          M = block_divide(block, 16)
          # Rounds
          a = FF(a, b, c, d, M[0], 7, SV[0])
          d = FF(d, a, b, c, M[1], 12, SV[1])
          c = FF(c, d, a, b, M[2], 17, SV[2])
          b = FF(b, c, d, a, M[3], 22, SV[3])
          a = FF(a, b, c, d, M[4], 7, SV[4])
          d = FF(d, a, b, c, M[5], 12, SV[5])
          c = FF(c, d, a, b, M[6], 17, SV[6])
          b = FF(b, c, d, a, M[7], 22, SV[7])
          a = FF(a, b, c, d, M[8], 7, SV[8])
          d = FF(d, a, b, c, M[9], 12, SV[9])
          c = FF(c, d, a, b, M[10], 17, SV[10])
          b = FF(b, c, d, a, M[11], 22, SV[11])
          a = FF(a, b, c, d, M[12], 7, SV[12])
          d = FF(d, a, b, c, M[13], 12, SV[13])
          c = FF(c, d, a, b, M[14], 17, SV[14])
          b = FF(b, c, d, a, M[15], 22, SV[15])
          a = GG(a, b, c, d, M[1], 5, SV[16])
          d = GG(d, a, b, c, M[6], 9, SV[17])
          c = GG(c, d, a, b, M[11], 14, SV[18])
          b = GG(b, c, d, a, M[0], 20, SV[19])
          a = GG(a, b, c, d, M[5], 5, SV[20])
          d = GG(d, a, b, c, M[10], 9, SV[21])
          c = GG(c, d, a, b, M[15], 14, SV[22])
          b = GG(b, c, d, a, M[4], 20, SV[23])
          a = GG(a, b, c, d, M[9], 5, SV[24])
          d = GG(d, a, b, c, M[14], 9, SV[25])
          c = GG(c, d, a, b, M[3], 14, SV[26])
          b = GG(b, c, d, a, M[8], 20, SV[27])
          a = GG(a, b, c, d, M[13], 5, SV[28])
          d = GG(d, a, b, c, M[2], 9, SV[29])
          c = GG(c, d, a, b, M[7], 14, SV[30])
          b = GG(b, c, d, a, M[12], 20, SV[31])
          a = HH(a, b, c, d, M[5], 4, SV[32])
          d = HH(d, a, b, c, M[8], 11, SV[33])
          c = HH(c, d, a, b, M[11], 16, SV[34])
          b = HH(b, c, d, a, M[14], 23, SV[35])
          a = HH(a, b, c, d, M[1], 4, SV[36])
          d = HH(d, a, b, c, M[4], 11, SV[37])
          c = HH(c, d, a, b, M[7], 16, SV[38])
          b = HH(b, c, d, a, M[10], 23, SV[39])
          a = HH(a, b, c, d, M[13], 4, SV[40])
          d = HH(d, a, b, c, M[0], 11, SV[41])
          c = HH(c, d, a, b, M[3], 16, SV[42])
          b = HH(b, c, d, a, M[6], 23, SV[43])
          a = HH(a, b, c, d, M[9], 4, SV[44])
          d = HH(d, a, b, c, M[12], 11, SV[45])
          c = HH(c, d, a, b, M[15], 16, SV[46])
          b = HH(b, c, d, a, M[2], 23, SV[47])
          a = II(a, b, c, d, M[0], 6, SV[48])
          d = II(d, a, b, c, M[7], 10, SV[49])
          c = II(c, d, a, b, M[14], 15, SV[50])
          b = II(b, c, d, a, M[5], 21, SV[51])
          a = II(a, b, c, d, M[12], 6, SV[52])
          d = II(d, a, b, c, M[3], 10, SV[53])
          c = II(c, d, a, b, M[10], 15, SV[54])
          b = II(b, c, d, a, M[1], 21, SV[55])
          a = II(a, b, c, d, M[8], 6, SV[56])
          d = II(d, a, b, c, M[15], 10, SV[57])
          c = II(c, d, a, b, M[6], 15, SV[58])
          b = II(b, c, d, a, M[13], 21, SV[59])
          a = II(a, b, c, d, M[4], 6, SV[60])
          d = II(d, a, b, c, M[11], 10, SV[61])
          c = II(c, d, a, b, M[2], 15, SV[62])
          b = II(b, c, d, a, M[9], 21, SV[63])
          A = (A + a) % (2 ** 32)
          B = (B + b) % (2 ** 32)
          C = (C + c) % (2 ** 32)
          D = (D + d) % (2 ** 32)
      result = fmt8(A) + fmt8(B) + fmt8(C) + fmt8(D)
      return result
  
  
  if __name__ == "__main__":
      data = 'spiderapi.cn - 虫术'
  
      result_lowercase_32bit = md5_hash(data.encode())
      result_uppercase_32bit = result_lowercase_32bit.upper()
      result_lowercase_16bit = result_lowercase_32bit[8:-8]
      result_uppercase_16bit = result_lowercase_16bit.upper()
  
      print("32 位小写值: ", result_lowercase_32bit)  # 4040361f7f0d278bf2781451e0639619
      print("32 位大写值: ", result_uppercase_32bit)  # 4040361F7F0D278BF2781451E0639619
      print("16 位小写值: ", result_lowercase_16bit)  # 7f0d278bf2781451
      print("16 位大写值: ", result_uppercase_16bit)  # 7F0D278BF2781451
  ```
  </code-block>
</code-group>

## JavaScript <Badge text="Node.js"/> <Badge text="ECMAScript 5.1+"/>

<code-group>
  <code-block title="依赖库 1️⃣" active>
  ```javascript
  // 安装依赖 npm install crypto-js
  
  var CryptoJS = require("crypto-js");
  
  var data = "spiderapi.cn - 虫术";
  var resultLowercase32bit = CryptoJS.MD5(data).toString(CryptoJS.enc.Hex);
  var resultUppercase32bit = resultLowercase32bit.toUpperCase();
  var resultLowercase16bit = resultLowercase32bit.slice(8, 24);
  var resultUppercase16bit = resultLowercase16bit.toUpperCase();
  
  console.log("32 位小写值:", resultLowercase32bit);
  console.log("32 位大写值:", resultUppercase32bit);
  console.log("16 位小写值:", resultLowercase16bit);
  console.log("16 位大写值:", resultUppercase16bit);
  ```
  </code-block>

  <code-block title="依赖库 2️⃣">
  ```javascript
  // 安装依赖 npm install crypto

  var crypto = require("crypto");
  
  var data = "spiderapi.cn - 虫术";
  var hashObject = crypto.createHash("md5");
  hashObject.update(data);
  var resultLowercase32bit = hashObject.digest("hex");
  var resultUppercase32bit = resultLowercase32bit.toUpperCase();
  var resultLowercase16bit = resultLowercase32bit.slice(8, 24);
  var resultUppercase16bit = resultLowercase16bit.toUpperCase();
  
  console.log("32 位小写值:", resultLowercase32bit);
  console.log("32 位大写值:", resultUppercase32bit);
  console.log("16 位小写值:", resultLowercase16bit);
  console.log("16 位大写值:", resultUppercase16bit);
  ```
  </code-block>

  <code-block title="依赖库 3️⃣">
  ```javascript
  // 安装依赖 npm install md5
  
  var MD5 = require("md5");

  var data = "spiderapi.cn - 虫术";
  var resultLowercase32bit = MD5(data);
  var resultUppercase32bit = resultLowercase32bit.toUpperCase();
  var resultLowercase16bit = resultLowercase32bit.slice(8, 24);
  var resultUppercase16bit = resultLowercase16bit.toUpperCase();
  
  console.log("32 位小写值:", resultLowercase32bit);
  console.log("32 位大写值:", resultUppercase32bit);
  console.log("16 位小写值:", resultLowercase16bit);
  console.log("16 位大写值:", resultUppercase16bit);
  ```
  </code-block>

  <code-block title="纯源码 1️⃣">
  ```javascript
  // 不借助官方或者第三方库，纯源码实现

  var CryptoJS = CryptoJS || (function (Math, undefined) {
      var crypto;
      if (typeof window !== 'undefined' && window.crypto) {
          crypto = window.crypto;
      }
      if (typeof self !== 'undefined' && self.crypto) {
          crypto = self.crypto;
      }
      if (typeof globalThis !== 'undefined' && globalThis.crypto) {
          crypto = globalThis.crypto;
      }
      if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
          crypto = window.msCrypto;
      }
      if (!crypto && typeof global !== 'undefined' && global.crypto) {
          crypto = global.crypto;
      }
      if (!crypto && typeof require === 'function') {
          try {
              crypto = require('crypto');
          } catch (err) {}
      }
      var cryptoSecureRandomInt = function () {
          if (crypto) {
              if (typeof crypto.getRandomValues === 'function') {
                  try {
                      return crypto.getRandomValues(new Uint32Array(1))[0];
                  } catch (err) {}
              }
              if (typeof crypto.randomBytes === 'function') {
                  try {
                      return crypto.randomBytes(4).readInt32LE();
                  } catch (err) {}
              }
          }
          throw new Error('Native crypto module could not be used to get secure random number.');
      };
      var create = Object.create || (function () {
          function F() {}
          return function (obj) {
              var subtype;
              F.prototype = obj;
              subtype = new F();
              F.prototype = null;
              return subtype;
          };
      }());
      var C = {};
      var C_lib = C.lib = {};
      var Base = C_lib.Base = (function () {
          return {
              extend: function (overrides) {
                  var subtype = create(this);
                  if (overrides) {
                      subtype.mixIn(overrides);
                  }
                  if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                      subtype.init = function () {
                          subtype.$super.init.apply(this, arguments);
                      };
                  }
                  subtype.init.prototype = subtype;
                  subtype.$super = this;
                  return subtype;
              }, create: function () {
                  var instance = this.extend();
                  instance.init.apply(instance, arguments);
                  return instance;
              }, init: function () {}, mixIn: function (properties) {
                  for (var propertyName in properties) {
                      if (properties.hasOwnProperty(propertyName)) {
                          this[propertyName] = properties[propertyName];
                      }
                  }
                  if (properties.hasOwnProperty('toString')) {
                      this.toString = properties.toString;
                  }
              }, clone: function () {
                  return this.init.prototype.extend(this);
              }
          };
      }());
      var WordArray = C_lib.WordArray = Base.extend({
          init: function (words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined) {
                  this.sigBytes = sigBytes;
              } else {
                  this.sigBytes = words.length * 4;
              }
          }, toString: function (encoder) {
              return (encoder || Hex).stringify(this);
          }, concat: function (wordArray) {
              var thisWords = this.words;
              var thatWords = wordArray.words;
              var thisSigBytes = this.sigBytes;
              var thatSigBytes = wordArray.sigBytes;
              this.clamp();
              if (thisSigBytes % 4) {
                  for (var i = 0; i < thatSigBytes; i++) {
                      var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                      thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                  }
              } else {
                  for (var j = 0; j < thatSigBytes; j += 4) {
                      thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
                  }
              }
              this.sigBytes += thatSigBytes;
              return this;
          }, clamp: function () {
              var words = this.words;
              var sigBytes = this.sigBytes;
              words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
              words.length = Math.ceil(sigBytes / 4);
          }, clone: function () {
              var clone = Base.clone.call(this);
              clone.words = this.words.slice(0);
              return clone;
          }, random: function (nBytes) {
              var words = [];
              var r = (function (m_w) {
                  var m_w = m_w;
                  var m_z = 0x3ade68b1;
                  var mask = 0xffffffff;
                  return function () {
                      m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
                      m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
                      var result = ((m_z << 0x10) + m_w) & mask;
                      result /= 0x100000000;
                      result += 0.5;
                      return result * (Math.random() > .5 ? 1 : -1);
                  }
              });
              var RANDOM = false, _r;
              try {
                  cryptoSecureRandomInt();
                  RANDOM = true;
              } catch (err) {}
              for (var i = 0, rcache; i < nBytes; i += 4) {
                  if (!RANDOM) {
                      _r = r((rcache || Math.random()) * 0x100000000);
                      rcache = _r() * 0x3ade67b7;
                      words.push((_r() * 0x100000000) | 0);
                      continue;
                  }
                  words.push(cryptoSecureRandomInt());
              }
              return new WordArray.init(words, nBytes);
          }
      });
      var C_enc = C.enc = {};
      var Hex = C_enc.Hex = {
          stringify: function (wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var hexChars = [];
              for (var i = 0; i < sigBytes; i++) {
                  var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                  hexChars.push((bite >>> 4).toString(16));
                  hexChars.push((bite & 0x0f).toString(16));
              }
              return hexChars.join('');
          }, parse: function (hexStr) {
              var hexStrLength = hexStr.length;
              var words = [];
              for (var i = 0; i < hexStrLength; i += 2) {
                  words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
              }
              return new WordArray.init(words, hexStrLength / 2);
          }
      };
      var Latin1 = C_enc.Latin1 = {
          stringify: function (wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var latin1Chars = [];
              for (var i = 0; i < sigBytes; i++) {
                  var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                  latin1Chars.push(String.fromCharCode(bite));
              }
              return latin1Chars.join('');
          }, parse: function (latin1Str) {
              var latin1StrLength = latin1Str.length;
              var words = [];
              for (var i = 0; i < latin1StrLength; i++) {
                  words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
              }
              return new WordArray.init(words, latin1StrLength);
          }
      };
      var Utf8 = C_enc.Utf8 = {
          stringify: function (wordArray) {
              try {
                  return decodeURIComponent(escape(Latin1.stringify(wordArray)));
              } catch (e) {
                  throw new Error('Malformed UTF-8 data');
              }
          }, parse: function (utf8Str) {
              return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
      };
      var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function () {
              this._data = new WordArray.init();
              this._nDataBytes = 0;
          }, _append: function (data) {
              if (typeof data == 'string') {
                  data = Utf8.parse(data);
              }
              this._data.concat(data);
              this._nDataBytes += data.sigBytes;
          }, _process: function (doFlush) {
              var processedWords;
              var data = this._data;
              var dataWords = data.words;
              var dataSigBytes = data.sigBytes;
              var blockSize = this.blockSize;
              var blockSizeBytes = blockSize * 4;
              var nBlocksReady = dataSigBytes / blockSizeBytes;
              if (doFlush) {
                  nBlocksReady = Math.ceil(nBlocksReady);
              } else {
                  nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
              }
              var nWordsReady = nBlocksReady * blockSize;
              var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
              if (nWordsReady) {
                  for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                      this._doProcessBlock(dataWords, offset);
                  }
                  processedWords = dataWords.splice(0, nWordsReady);
                  data.sigBytes -= nBytesReady;
              }
              return new WordArray.init(processedWords, nBytesReady);
          }, clone: function () {
              var clone = Base.clone.call(this);
              clone._data = this._data.clone();
              return clone;
          }, _minBufferSize: 0
      });
      var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function (cfg) {
              this.cfg = this.cfg.extend(cfg);
              this.reset();
          }, reset: function () {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
          }, update: function (messageUpdate) {
              this._append(messageUpdate);
              this._process();
              return this;
          }, finalize: function (messageUpdate) {
              if (messageUpdate) {
                  this._append(messageUpdate);
              }
              var hash = this._doFinalize();
              return hash;
          }, blockSize: 512 / 32,
          _createHelper: function (hasher) {
              return function (message, cfg) {
                  return new hasher.init(cfg).finalize(message);
              };
          }, _createHmacHelper: function (hasher) {
              return function (message, key) {
                  return new C_algo.HMAC.init(hasher, key).finalize(message);
              };
          }
      });
      var C_algo = C.algo = {};
      return C;
  }(Math));

  (function (Math) {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var Hasher = C_lib.Hasher;
      var C_algo = C.algo;
      var T = [];
      (function () {
          for (var i = 0; i < 64; i++) {
              T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
          }
      }());
      var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function () {
              this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
          }, _doProcessBlock: function (M, offset) {
              for (var i = 0; i < 16; i++) {
                  var offset_i = offset + i;
                  var M_offset_i = M[offset_i];
                  M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
              }
              var H = this._hash.words;
              var M_offset_0 = M[offset + 0];
              var M_offset_1 = M[offset + 1];
              var M_offset_2 = M[offset + 2];
              var M_offset_3 = M[offset + 3];
              var M_offset_4 = M[offset + 4];
              var M_offset_5 = M[offset + 5];
              var M_offset_6 = M[offset + 6];
              var M_offset_7 = M[offset + 7];
              var M_offset_8 = M[offset + 8];
              var M_offset_9 = M[offset + 9];
              var M_offset_10 = M[offset + 10];
              var M_offset_11 = M[offset + 11];
              var M_offset_12 = M[offset + 12];
              var M_offset_13 = M[offset + 13];
              var M_offset_14 = M[offset + 14];
              var M_offset_15 = M[offset + 15];
              var a = H[0];
              var b = H[1];
              var c = H[2];
              var d = H[3];
              a = FF(a, b, c, d, M_offset_0, 7, T[0]);
              d = FF(d, a, b, c, M_offset_1, 12, T[1]);
              c = FF(c, d, a, b, M_offset_2, 17, T[2]);
              b = FF(b, c, d, a, M_offset_3, 22, T[3]);
              a = FF(a, b, c, d, M_offset_4, 7, T[4]);
              d = FF(d, a, b, c, M_offset_5, 12, T[5]);
              c = FF(c, d, a, b, M_offset_6, 17, T[6]);
              b = FF(b, c, d, a, M_offset_7, 22, T[7]);
              a = FF(a, b, c, d, M_offset_8, 7, T[8]);
              d = FF(d, a, b, c, M_offset_9, 12, T[9]);
              c = FF(c, d, a, b, M_offset_10, 17, T[10]);
              b = FF(b, c, d, a, M_offset_11, 22, T[11]);
              a = FF(a, b, c, d, M_offset_12, 7, T[12]);
              d = FF(d, a, b, c, M_offset_13, 12, T[13]);
              c = FF(c, d, a, b, M_offset_14, 17, T[14]);
              b = FF(b, c, d, a, M_offset_15, 22, T[15]);
              a = GG(a, b, c, d, M_offset_1, 5, T[16]);
              d = GG(d, a, b, c, M_offset_6, 9, T[17]);
              c = GG(c, d, a, b, M_offset_11, 14, T[18]);
              b = GG(b, c, d, a, M_offset_0, 20, T[19]);
              a = GG(a, b, c, d, M_offset_5, 5, T[20]);
              d = GG(d, a, b, c, M_offset_10, 9, T[21]);
              c = GG(c, d, a, b, M_offset_15, 14, T[22]);
              b = GG(b, c, d, a, M_offset_4, 20, T[23]);
              a = GG(a, b, c, d, M_offset_9, 5, T[24]);
              d = GG(d, a, b, c, M_offset_14, 9, T[25]);
              c = GG(c, d, a, b, M_offset_3, 14, T[26]);
              b = GG(b, c, d, a, M_offset_8, 20, T[27]);
              a = GG(a, b, c, d, M_offset_13, 5, T[28]);
              d = GG(d, a, b, c, M_offset_2, 9, T[29]);
              c = GG(c, d, a, b, M_offset_7, 14, T[30]);
              b = GG(b, c, d, a, M_offset_12, 20, T[31]);
              a = HH(a, b, c, d, M_offset_5, 4, T[32]);
              d = HH(d, a, b, c, M_offset_8, 11, T[33]);
              c = HH(c, d, a, b, M_offset_11, 16, T[34]);
              b = HH(b, c, d, a, M_offset_14, 23, T[35]);
              a = HH(a, b, c, d, M_offset_1, 4, T[36]);
              d = HH(d, a, b, c, M_offset_4, 11, T[37]);
              c = HH(c, d, a, b, M_offset_7, 16, T[38]);
              b = HH(b, c, d, a, M_offset_10, 23, T[39]);
              a = HH(a, b, c, d, M_offset_13, 4, T[40]);
              d = HH(d, a, b, c, M_offset_0, 11, T[41]);
              c = HH(c, d, a, b, M_offset_3, 16, T[42]);
              b = HH(b, c, d, a, M_offset_6, 23, T[43]);
              a = HH(a, b, c, d, M_offset_9, 4, T[44]);
              d = HH(d, a, b, c, M_offset_12, 11, T[45]);
              c = HH(c, d, a, b, M_offset_15, 16, T[46]);
              b = HH(b, c, d, a, M_offset_2, 23, T[47]);
              a = II(a, b, c, d, M_offset_0, 6, T[48]);
              d = II(d, a, b, c, M_offset_7, 10, T[49]);
              c = II(c, d, a, b, M_offset_14, 15, T[50]);
              b = II(b, c, d, a, M_offset_5, 21, T[51]);
              a = II(a, b, c, d, M_offset_12, 6, T[52]);
              d = II(d, a, b, c, M_offset_3, 10, T[53]);
              c = II(c, d, a, b, M_offset_10, 15, T[54]);
              b = II(b, c, d, a, M_offset_1, 21, T[55]);
              a = II(a, b, c, d, M_offset_8, 6, T[56]);
              d = II(d, a, b, c, M_offset_15, 10, T[57]);
              c = II(c, d, a, b, M_offset_6, 15, T[58]);
              b = II(b, c, d, a, M_offset_13, 21, T[59]);
              a = II(a, b, c, d, M_offset_4, 6, T[60]);
              d = II(d, a, b, c, M_offset_11, 10, T[61]);
              c = II(c, d, a, b, M_offset_2, 15, T[62]);
              b = II(b, c, d, a, M_offset_9, 21, T[63]);
              H[0] = (H[0] + a) | 0;
              H[1] = (H[1] + b) | 0;
              H[2] = (H[2] + c) | 0;
              H[3] = (H[3] + d) | 0;
          }, _doFinalize: function () {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
              var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
              var nBitsTotalL = nBitsTotal;
              dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));
              dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash = this._hash;
              var H = hash.words;
              for (var i = 0; i < 4; i++) {
                  var H_i = H[i];
                  H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
              }
              return hash;
          }, clone: function () {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
          }
      });
      function FF(a, b, c, d, x, s, t) {
          var n = a + ((b & c) | (~b & d)) + x + t;
          return ((n << s) | (n >>> (32 - s))) + b;
      }
      function GG(a, b, c, d, x, s, t) {
          var n = a + ((b & d) | (c & ~d)) + x + t;
          return ((n << s) | (n >>> (32 - s))) + b;
      }
      function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return ((n << s) | (n >>> (32 - s))) + b;
      }
      function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return ((n << s) | (n >>> (32 - s))) + b;
      }
      C.MD5 = Hasher._createHelper(MD5);
      C.HmacMD5 = Hasher._createHmacHelper(MD5);
  }(Math));
  
  
  var data = "spiderapi.cn - 虫术";
  var resultLowercase32bit = CryptoJS.MD5(data).toString(CryptoJS.enc.Hex);
  var resultUppercase32bit = resultLowercase32bit.toUpperCase();
  var resultLowercase16bit = resultLowercase32bit.slice(8, 24);
  var resultUppercase16bit = resultLowercase16bit.toUpperCase();
  
  console.log("32 位小写值:", resultLowercase32bit);
  console.log("32 位大写值:", resultUppercase32bit);
  console.log("16 位小写值:", resultLowercase16bit);
  console.log("16 位大写值:", resultUppercase16bit);
  ```
  </code-block>
  
  <code-block title="纯源码 2️⃣">
  ```javascript
  // 不借助官方或者第三方库，纯源码实现
  
  function md5Hash(instring) {
      var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
      var b64pad = "";  /* base-64 pad character. "=" for strict RFC compliance   */
  
      /*
       * These are the functions you'll usually want to call
       * They take string arguments and return either hex or base-64 encoded strings
       */
      function hex_md5(s) {
          return rstr2hex(rstr_md5(str2rstr_utf8(s)));
      }
  
      function b64_md5(s) {
          return rstr2b64(rstr_md5(str2rstr_utf8(s)));
      }
  
      function any_md5(s, e) {
          return rstr2any(rstr_md5(str2rstr_utf8(s)), e);
      }
  
      function hex_hmac_md5(k, d) {
          return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
      }
  
      function b64_hmac_md5(k, d) {
          return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
      }
  
      function any_hmac_md5(k, d, e) {
          return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e);
      }
  
      /*
       * Calculate the MD5 of a raw string
       */
      function rstr_md5(s) {
          return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
      }
  
      /*
       * Calculate the HMAC-MD5, of a key and some data (raw strings)
       */
      function rstr_hmac_md5(key, data) {
          var bkey = rstr2binl(key);
          if (bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);
  
          var ipad = Array(16), opad = Array(16);
          for (var i = 0; i < 16; i++) {
              ipad[i] = bkey[i] ^ 0x36363636;
              opad[i] = bkey[i] ^ 0x5C5C5C5C;
          }
  
          var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
          return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
      }
  
      /*
       * Convert a raw string to a hex string
       */
      function rstr2hex(input) {
          try {
              hexcase
          } catch (e) {
              hexcase = 0;
          }
          var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
          var output = "";
          var x;
          for (var i = 0; i < input.length; i++) {
              x = input.charCodeAt(i);
              output += hex_tab.charAt((x >>> 4) & 0x0F)
                  + hex_tab.charAt(x & 0x0F);
          }
          return output;
      }
  
      /*
       * Convert a raw string to a base-64 string
       */
      function rstr2b64(input) {
          try {
              b64pad
          } catch (e) {
              b64pad = '';
          }
          var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var output = "";
          var len = input.length;
          for (var i = 0; i < len; i += 3) {
              var triplet = (input.charCodeAt(i) << 16)
                  | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0)
                  | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
              for (var j = 0; j < 4; j++) {
                  if (i * 8 + j * 6 > input.length * 8) output += b64pad;
                  else output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);
              }
          }
          return output;
      }
  
      /*
       * Convert a raw string to an arbitrary string encoding
       */
      function rstr2any(input, encoding) {
          var divisor = encoding.length;
          var i, j, q, x, quotient;
  
          /* Convert to an array of 16-bit big-endian values, forming the dividend */
          var dividend = Array(Math.ceil(input.length / 2));
          for (i = 0; i < dividend.length; i++) {
              dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
          }
  
          /*
           * Repeatedly perform a long division. The binary array forms the dividend,
           * the length of the encoding is the divisor. Once computed, the quotient
           * forms the dividend for the next step. All remainders are stored for later
           * use.
           */
          var full_length = Math.ceil(input.length * 8 /
              (Math.log(encoding.length) / Math.log(2)));
          var remainders = Array(full_length);
          for (j = 0; j < full_length; j++) {
              quotient = Array();
              x = 0;
              for (i = 0; i < dividend.length; i++) {
                  x = (x << 16) + dividend[i];
                  q = Math.floor(x / divisor);
                  x -= q * divisor;
                  if (quotient.length > 0 || q > 0)
                      quotient[quotient.length] = q;
              }
              remainders[j] = x;
              dividend = quotient;
          }
  
          /* Convert the remainders to the output string */
          var output = "";
          for (i = remainders.length - 1; i >= 0; i--)
              output += encoding.charAt(remainders[i]);
  
          return output;
      }
  
      /*
       * Encode a string as utf-8.
       * For efficiency, this assumes the input is valid utf-16.
       */
      function str2rstr_utf8(input) {
          var output = "";
          var i = -1;
          var x, y;
  
          while (++i < input.length) {
              /* Decode utf-16 surrogate pairs */
              x = input.charCodeAt(i);
              y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
              if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
                  x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
                  i++;
              }
  
              /* Encode output as utf-8 */
              if (x <= 0x7F)
                  output += String.fromCharCode(x);
              else if (x <= 0x7FF)
                  output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F),
                      0x80 | (x & 0x3F));
              else if (x <= 0xFFFF)
                  output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                      0x80 | ((x >>> 6) & 0x3F),
                      0x80 | (x & 0x3F));
              else if (x <= 0x1FFFFF)
                  output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                      0x80 | ((x >>> 12) & 0x3F),
                      0x80 | ((x >>> 6) & 0x3F),
                      0x80 | (x & 0x3F));
          }
          return output;
      }
  
      /*
       * Encode a string as utf-16
       */
      function str2rstr_utf16le(input) {
          var output = "";
          for (var i = 0; i < input.length; i++)
              output += String.fromCharCode(input.charCodeAt(i) & 0xFF,
                  (input.charCodeAt(i) >>> 8) & 0xFF);
          return output;
      }
  
      function str2rstr_utf16be(input) {
          var output = "";
          for (var i = 0; i < input.length; i++)
              output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                  input.charCodeAt(i) & 0xFF);
          return output;
      }
  
      /*
       * Convert a raw string to an array of little-endian words
       * Characters >255 have their high-byte silently ignored.
       */
      function rstr2binl(input) {
          var output = Array(input.length >> 2);
          for (var i = 0; i < output.length; i++)
              output[i] = 0;
          for (var i = 0; i < input.length * 8; i += 8)
              output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
          return output;
      }
  
      /*
       * Convert an array of little-endian words to a string
       */
      function binl2rstr(input) {
          var output = "";
          for (var i = 0; i < input.length * 32; i += 8)
              output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
          return output;
      }
  
      /*
       * Calculate the MD5 of an array of little-endian words, and a bit length.
       */
      function binl_md5(x, len) {
          /* append padding */
          x[len >> 5] |= 0x80 << ((len) % 32);
          x[(((len + 64) >>> 9) << 4) + 14] = len;
  
          var a = 1732584193;
          var b = -271733879;
          var c = -1732584194;
          var d = 271733878;
  
          for (var i = 0; i < x.length; i += 16) {
              var olda = a;
              var oldb = b;
              var oldc = c;
              var oldd = d;
  
              a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
              d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
              c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
              b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
              a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
              d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
              c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
              b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
              a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
              d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
              c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
              b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
              a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
              d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
              c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
              b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
  
              a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
              d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
              c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
              b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
              a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
              d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
              c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
              b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
              a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
              d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
              c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
              b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
              a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
              d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
              c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
              b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
  
              a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
              d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
              c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
              b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
              a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
              d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
              c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
              b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
              a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
              d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
              c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
              b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
              a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
              d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
              c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
              b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
  
              a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
              d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
              c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
              b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
              a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
              d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
              c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
              b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
              a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
              d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
              c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
              b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
              a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
              d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
              c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
              b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
  
              a = safe_add(a, olda);
              b = safe_add(b, oldb);
              c = safe_add(c, oldc);
              d = safe_add(d, oldd);
          }
          return Array(a, b, c, d);
      }
  
      /*
       * These functions implement the four basic operations the algorithm uses.
       */
      function md5_cmn(q, a, b, x, s, t) {
          return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
      }
  
      function md5_ff(a, b, c, d, x, s, t) {
          return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
      }
  
      function md5_gg(a, b, c, d, x, s, t) {
          return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
      }
  
      function md5_hh(a, b, c, d, x, s, t) {
          return md5_cmn(b ^ c ^ d, a, b, x, s, t);
      }
  
      function md5_ii(a, b, c, d, x, s, t) {
          return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
      }
  
      /*
       * Add integers, wrapping at 2^32. This uses 16-bit operations internally
       * to work around bugs in some JS interpreters.
       */
      function safe_add(x, y) {
          var lsw = (x & 0xFFFF) + (y & 0xFFFF);
          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return (msw << 16) | (lsw & 0xFFFF);
      }
  
      /*
       * Bitwise rotate a 32-bit number to the left.
       */
      function bit_rol(num, cnt) {
          return (num << cnt) | (num >>> (32 - cnt));
      }
  
      return hex_md5(instring);
  }
  
  var data = "spiderapi.cn - 虫术";
  var resultLowercase32bit = md5Hash(data);
  var resultUppercase32bit = resultLowercase32bit.toUpperCase();
  var resultLowercase16bit = resultLowercase32bit.slice(8, 24);
  var resultUppercase16bit = resultLowercase16bit.toUpperCase();
  
  console.log("32 位小写值:", resultLowercase32bit);
  console.log("32 位大写值:", resultUppercase32bit);
  console.log("16 位小写值:", resultLowercase16bit);
  console.log("16 位大写值:", resultUppercase16bit);
  ```
  </code-block>

</code-group>

## Golang <Badge text="1.0+"/>

<code-group>
  <code-block title="依赖库 1️⃣" active>
  ```go
  // 方法一：使用 md5.New 创建哈希对象

  package main
  
  import (
      "crypto/md5"
      "encoding/hex"
      "fmt"
      "strings"
  )
  
  func md5Hash(data string) string {
      hashObject := md5.New()
      hashObject.Write([]byte(data))
      hashBytes := hashObject.Sum(nil)
      hashString := hex.EncodeToString(hashBytes)
      return hashString
  }
  
  func main() {
      data := "spiderapi.cn - 虫术"
      resultLowercase32bit := md5Hash(data)
      resultUppercase32bit := strings.ToUpper(resultLowercase32bit)
      resultLowercase16bit := resultLowercase32bit[8:24]
      resultUppercase16bit := strings.ToUpper(resultLowercase16bit)
      fmt.Println("32 位小写值: ", resultLowercase32bit)
      fmt.Println("32 位大写值: ", resultUppercase32bit)
      fmt.Println("16 位小写值: ", resultLowercase16bit)
      fmt.Println("16 位大写值: ", resultUppercase16bit)
  }
  ```
  </code-block>
  
  <code-block title="依赖库 2️⃣">
  ```go
  // 方法二：使用 io 包将字符串写入哈希对象
  
  package main
  
  import (
      "crypto/md5"
      "encoding/hex"
      "fmt"
      "io"
      "strings"
  )
  
  func md5Hash(data string) string {
      hashObject := md5.New()
      _, err := io.WriteString(hashObject, data)
      if err != nil {
          fmt.Println("md5Hash error:", err)
          return ""
      }
      hashBytes := hashObject.Sum(nil)
      hashString := hex.EncodeToString(hashBytes)
      return hashString
  }
  
  func main() {
      data := "spiderapi.cn - 虫术"
      resultLowercase32bit := md5Hash(data)
      resultUppercase32bit := strings.ToUpper(resultLowercase32bit)
      resultLowercase16bit := resultLowercase32bit[8:24]
      resultUppercase16bit := strings.ToUpper(resultLowercase16bit)
      fmt.Println("32 位小写值: ", resultLowercase32bit)
      fmt.Println("32 位大写值: ", resultUppercase32bit)
      fmt.Println("16 位小写值: ", resultLowercase16bit)
      fmt.Println("16 位大写值: ", resultUppercase16bit)
  }
  ```
  </code-block>
  
  <code-block title="依赖库 3️⃣">
  ```go
  // 方法三：使用 md5.Sum 函数计算哈希值

  package main
  
  import (
      "crypto/md5"
      "encoding/hex"
      "fmt"
      "strings"
  )
  
  func md5Hash(data string) string {
      hashBytes := md5.Sum([]byte(data))
      hashString := hex.EncodeToString(hashBytes[:])
      return hashString
  }
  
  func main() {
      data := "spiderapi.cn - 虫术"
      resultLowercase32bit := md5Hash(data)
      resultUppercase32bit := strings.ToUpper(resultLowercase32bit)
      resultLowercase16bit := resultLowercase32bit[8:24]
      resultUppercase16bit := strings.ToUpper(resultLowercase16bit)
      fmt.Println("32 位小写值: ", resultLowercase32bit)
      fmt.Println("32 位大写值: ", resultUppercase32bit)
      fmt.Println("16 位小写值: ", resultLowercase16bit)
      fmt.Println("16 位大写值: ", resultUppercase16bit)
  }
  ```
  </code-block>
  
  <code-block title="纯源码">
  ```go
  // 不借助官方或者第三方库，纯源码实现
  
  package main
  
  import (
      "bytes"
      "encoding/binary"
      "fmt"
      "math"
      "strings"
  )
  
  var shift = [...]uint{7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21}
  var table [64]uint32
  
  func init() {
      for i := range table {
          table[i] = uint32((1 << 32) * math.Abs(math.Sin(float64(i+1))))
      }
  }
  
  func md5Hash(s string) string {
      padded := bytes.NewBuffer([]byte(s))
      padded.WriteByte(0x80)
      for padded.Len()%64 != 56 {
          padded.WriteByte(0)
      }
      messageLenBits := uint64(len(s)) * 8
      err := binary.Write(padded, binary.LittleEndian, messageLenBits)
      if err != nil {
          return ""
      }
    
      var a, b, c, d uint32 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476
      var buffer [16]uint32
      for binary.Read(padded, binary.LittleEndian, buffer[:]) == nil { // read every 64 bytes
          a1, b1, c1, d1 := a, b, c, d
          for j := 0; j < 64; j++ {
              var f uint32
              bufferIndex := j
              round := j >> 4
              switch round {
              case 0:
                  f = (b1 & c1) | (^b1 & d1)
              case 1:
                  f = (b1 & d1) | (c1 & ^d1)
                  bufferIndex = (bufferIndex*5 + 1) & 0x0F
              case 2:
                  f = b1 ^ c1 ^ d1
                  bufferIndex = (bufferIndex*3 + 5) & 0x0F
              case 3:
                  f = c1 ^ (b1 | ^d1)
                  bufferIndex = (bufferIndex * 7) & 0x0F
              }
              sa := shift[(round<<2)|(j&3)]
              a1 += f + buffer[bufferIndex] + table[j]
              a1, d1, c1, b1 = d1, c1, b1, a1<<sa|a1>>(32-sa)+b1
          }
          a, b, c, d = a+a1, b+b1, c+c1, d+d1
      }
    
      var result [16]byte
      binary.LittleEndian.PutUint32(result[0:4], a)
      binary.LittleEndian.PutUint32(result[4:8], b)
      binary.LittleEndian.PutUint32(result[8:12], c)
      binary.LittleEndian.PutUint32(result[12:16], d)
      return fmt.Sprintf("%x", result)
  }
  
  func main() {
      data := "spiderapi.cn - 虫术"
      resultLowercase32bit := md5Hash(data)
      resultUppercase32bit := strings.ToUpper(resultLowercase32bit)
      resultLowercase16bit := resultLowercase32bit[8:24]
      resultUppercase16bit := strings.ToUpper(resultLowercase16bit)
      fmt.Println("32 位小写值: ", resultLowercase32bit)
      fmt.Println("32 位大写值: ", resultUppercase32bit)
      fmt.Println("16 位小写值: ", resultLowercase16bit)
      fmt.Println("16 位大写值: ", resultUppercase16bit)
  }
  ```
  </code-block>
</code-group>

## 主要特征

MD5 的 hash 值具有明显的特征，实现该算法的源代码里也有一些固定的特征值，没有这些特定值，就无法实现 MD5，我们可以通过密文特征和搜索源码特征值来快速判断是否为 MD5 算法。

密文特征：

- 密文一般为 <font color="red">**16 位**</font>或者 <font color="red">**32 位**</font>，其中 16 位是取的 32 位第 9~25 位的值；
- 组成方式为字母（<font color="red">**a-f**</font>）和数字（<font color="red">**0-9**</font>）混合，字母可以全部是大写或者小写。

源码特征值：

- `0123456789ABCDEF`、`0123456789abcdef`
- `1732584193`、`-271733879`、`-1732584194`、`271733878`
- `0x67452301`、`0xefcdab89`、`0x98badcfe`、`0x10325476`

PS：某些特殊情况下，密文的长度也有可能不止 16 位或者 32 位，有可能是在官方算法上有一些魔改，通常也是在 16 位的基础上，左右填充了一些随机字符串。

示例：

| 编码类型   | 示例一                                | 示例二                                |
|:-------|:-----------------------------------|------------------------------------|
| 明文     | 01234567890                        | administrators                     |
| 32 位小写 | `ebe596017db2f8c69136e5d6e594d365` | `d04952b3df94d47c04fc2dc28396a62d` |
| 32 位大写 | `EBE596017DB2F8C69136E5D6E594D365` | `D04952B3DF94D47C04FC2DC28396A62D` |
| 16 位小写 | `7db2f8c69136e5d6`                 | `df94d47c04fc2dc2`                 |
| 16 位大写 | `7DB2F8C69136E5D6`                 | `DF94D47C04FC2DC2`                 |


## 在线工具

[https://www.sojson.com/encrypt_md5.html](https://www.sojson.com/encrypt_md5.html)
